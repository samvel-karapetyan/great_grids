# «Great Grid» խնդրի լուծման բացատրություն

## Խնդրի ամփոփում

Պետք է ստացվի (n x m) ցանց, որտեղ՝
1. Յուրաքանչյուր բջիջը մեկ տառ է՝ `'A'`, `'B'` կամ `'C'`
2. Ցանկացած 2×2 ենթացանց պետք է պարունակի բոլոր երեք տառերը
3. Կողքով հարակից (ընդհանուր եզր ունեցող) երկու բջիջներում տառերը տարբեր են

Տրված են (k) սահմանափակումներ. Յուրաքանչյուր սահմանափակումը նշում է երկու դիրք, որոնք հարևան են մեկ անկյունով՝ `(x1, y1)` և `(x1 + 1, y1 ± 1)`, ու պահանջում է, որ այդ երկու դիրքերում տառը նույնը լինի։ Պետք է որոշել՝ հնարավոր է արդյոք նման «լավ» ցանց կառուցել։

## Գլխավոր գաղափարը՝ ցանցի կառուցվածքը

Ցանկացած «լավ» ցանց կարելի է ներկայացնել այսպես՝

```
cell(i, j) = (f(i) + g(j)) (mod 3)
```

որտեղ՝
- `f` : տողը -> `{0, 1, 2}` և պարտադիր է, որ `f(i) != f(i + 1)` բոլոր i-երի համար
- `g` : սյունը -> `{0, 1, 2}` և պարտադիր է, որ `g(j) != g(j+1)` բոլոր j-երի համար
- 0,1,2 արժեքները համապատասխանում են տառերին `A,B,C`

### Հիմնավորում

**Եզրով հարակիցների պայմանը** պահպանվում է, որովհետև՝
- Հորիզոնական՝ `f(i) + g(j) != f(i) + g(j+1)`, քանի որ `g(j) != g(j+1)`
- Ուղղահայաց՝ `f(i) + g(j) != f(i+1) + g(j)`, քանի որ `f(i) != f(i+1)`

**2×2 պայմանը**. Ցանկացած 2×2 բլոկում ստացվում են չորս արժեք՝

```
f(i)+g(j),     f(i)+g(j)+Δg,
f(i)+Δf+g(j),  f(i)+Δf+g(j)+Δg
```

որտեղ `Δf, Δg ∈ {1,2}` (0-ն չկա, քանի որ հարակիցները չեն կարող լինել նույնը)։ Այս չորս արժեքների մեջ ըստ (mod 3)֊ի միշտ հայտնվում են 0,1,2 թվերը, այսինքն՝ տվյալ 2×2-ում պարտադիր կլինի բոլոր երեք տառերը։

## Բերում 2-ական ընտրության խնդրի

Քանի որ հարակից արժեքները պետք է տարբեր լինեն, ապա՝
- `Δf(i) = f(i+1) - f(i) ∈ {1, 2}` — սա արդեն 2 տարբերակ է
- `Δg(j) = g(j+1) - g(j) ∈ {1, 2}` — սա նույնպես 2 տարբերակ է

Սահմանենք բինար փոփոխականներ՝
- `r[i] = 1`, եթե `Δf(i) = 1`, հակառակ դեպքում `r[i] = 0` (այսինքն `Δf(i) = 2`)
- `c[j] = 1`, եթե `Δg(j) = 1`, հակառակ դեպքում `c[j] = 0`

### Սահմանափակումների վերաձևակերպումը

Տրված սահամանփակումներից է՝ `cell(x1, y1) = cell(x2, y2)`։

**Դեպք 1: `y2 = y1 + 1`** (աջ-ներքևի հարևան)

```
cell(x1, y1) = cell(x2, y2)
=> f(x1) + g(y1) ≡ f(x1+1) + g(y1+1) (mod 3)
=> -f(x1+1) + f(x1) ≡ g(y1+1) - g(y1) (mod 3)
=> -Δf(x1) ≡ Δg(y1) (mod 3)
```

Քանի որ `Δf, Δg ∈ {1,2}`, սա նշանակում է՝ մեկը պետք է լինի 1, մյուսը՝ 2։ 

Այսինքն՝
- **r[x1] != c[y1]**

**Դեպք 2: `y2 = y1 - 1`** (ձախ-ներքևի հարևան)

```
cell(x1, y1) = cell(x2, y2)
=> f(x1) + g(y1) ≡ f(x1+1) + g(y1-1) (mod 3)
=> g(y1) -  g(y1-1) ≡ f(x1+1) - f(x1) (mod 3)
Δf(x1) ≡ Δg(y1-1) (mod 3)
```

Սա նշանակում է՝

- **r[x1] = c[y1-1]**

## Բերում գրաֆի 2-գունավորման խնդրի

Հիմա ունենք՝
- Փոփոխականներ՝ `r[1], ..., r[n-1]` և `c[1], ..., c[m-1]`
- Պահանջներ՝ որոշ զույգեր պետք է լինեն հավասար, իսկ որոշները՝ տարբեր

Սա հենց **2-գունավորման** խնդիր է.
1. Ամեն փոփոխականի համար ստեղծում ենք գրաֆի գագաթ
2. Յուրաքանչյուր սահմանափակման համար ավելացնում ենք կող՝ «նույն» կամ «տարբեր» պիտակով
3. Ստուգում ենք՝ կա՞ արդյոք 0/1 արժեքավորում, որը բոլոր կողերին համապատասխանում է

### Ալգորիթմ

```
Յուրաքանչյուր կապակցված բաղադրիչում՝
    BFS/DFS-ով դնում ենք գույներ 0 կամ 1
    Եթե կողը «նույն» է՝ color[v] = color[u]
    Եթե կողը «տարբեր» է՝ color[v] = 1 - color[u]
    Եթե հակասություն գտանք → NO
Եթե բոլոր բաղադրիչները անցան առանց հակասության → YES
```

## Բարդություն

k սահմանափակումների ավելացում -> O(k)

BFS -> O(n + m)

- **Ժամանակ**՝ O(n + m + k) յուրաքանչյուր թեստի համար